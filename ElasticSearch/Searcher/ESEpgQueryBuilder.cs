using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ApiObjects.SearchObjects;
using ElasticSearch.Common;

namespace ElasticSearch.Searcher
{
    public class ESEpgQueryBuilder
    {

        protected static readonly List<string> DEFAULT_RETURN_FIELDS = new List<string>(8) { "\"_id\"", "\"_index\"", "\"_type\"", "\"_score\"", "\"group_id\"", "\"epg_id\"", "\"name\", \"cache_date\"" };
        public static readonly string AND_CONDITION = "AND";
        public static readonly string OR_CONDITION = "OR";
        public static readonly string METAS = "METAS";
        public static readonly string TAGS = "TAGS";
        protected readonly int MAX_RESULTS;

        public EpgSearchObj m_oEpgSearchObj { get; set; }
        public eQueryAnalyzer eAnalyzer { get; set; }
        public bool bAnalyzeWildcards { get; set; }
        public List<string> ReturnFields { get; protected set; }
        
        public ESEpgQueryBuilder()
        {
            ReturnFields = DEFAULT_RETURN_FIELDS;
            string sMaxResults = Common.Utils.GetWSURL("MAX_RESULTS");
            if (!int.TryParse(sMaxResults, out MAX_RESULTS))
                MAX_RESULTS = 100000;
        }

        private int CalcNumOfRequests()
        {
            int res = 1;
            if (m_oEpgSearchObj.m_bSearchOnlyDatesAndChannels)
            {
                if (m_oEpgSearchObj.m_bIsCurrent)
                {
                    // 2 es requests for each epg channel id
                    res = m_oEpgSearchObj.m_oEpgChannelIDs.Count << 1;
                }
                else
                {
                    // es request per epg channel id
                    res = m_oEpgSearchObj.m_oEpgChannelIDs.Count;
                }
            }

            return res;

        }

        public virtual List<string> BuildSearchQueryStrings()
        {
            int numOfRequests = CalcNumOfRequests();
            List<string> res = new List<string>(numOfRequests);

            if (numOfRequests == 1 && !m_oEpgSearchObj.m_bSearchOnlyDatesAndChannels)
            {
                /*
                 * 1. numOfRequest == 1 && !m_oEpgSearchObj.m_bSearchOnlyDatesAndChannels means I came from an EPGSearchRequest object.
                 * 2. Not satisfying these contraints means I came from EpgRequest. EpgRequest always sets true the flag
                 *    !m_oEpgSearchObj.m_bSearchOnlyDatesAndChannels. Furthermore, Only EpgRequest with the following flags:
                 *       a. ByDate AND
                 *       b. epgChannelIDs.Count == 1
                 *    produces numOfRequest == 1. All other requests generated by EpgRequest have numOfRequests > 1.
                 */
                FilteredQuery filteredQuery = new FilteredQuery();
                ESWildcard wildCard;
                BoolQuery mainBooleanQuery = new BoolQuery();

                BoolQuery textBooleanQueryOR = new BoolQuery();
                BoolQuery textBooleanQueryAnd = new BoolQuery();

                //And OR List search rexts
                foreach (SearchValue kvp in m_oEpgSearchObj.m_lSearchOr)
                {
                    if (!m_oEpgSearchObj.m_bExact)
                    {
                        wildCard = new ESWildcard()
                        {
                            Key = Common.Utils.ReplaceQueryReservedCharacters(ref kvp.m_sKey),
                            Value = string.Format("*{0}*", Common.Utils.ReplaceQueryReservedCharacters(ref kvp.m_sValue))
                        };
                    }
                    else
                    {
                        wildCard = new ESWildcard()
                        {
                            Key = Common.Utils.ReplaceQueryReservedCharacters(ref kvp.m_sKey),
                            Value = string.Format("{0}", Common.Utils.ReplaceQueryReservedCharacters(ref kvp.m_sValue))
                        };
                    }
                    textBooleanQueryOR.AddChild(wildCard, CutWith.OR);
                }

                mainBooleanQuery.AddChild(textBooleanQueryOR, CutWith.AND);

                if (m_oEpgSearchObj.m_bExact && m_oEpgSearchObj != null && m_oEpgSearchObj.m_lSearchAnd.Count > 0)
                {
                    foreach (SearchValue kvp in m_oEpgSearchObj.m_lSearchAnd)
                    {

                        wildCard = new ESWildcard()
                        {
                            Key = Common.Utils.ReplaceQueryReservedCharacters(ref kvp.m_sKey),
                            Value = string.Format("{0}", Common.Utils.ReplaceQueryReservedCharacters(ref kvp.m_sValue))
                        };

                        textBooleanQueryAnd.AddChild(wildCard, CutWith.AND);
                    }

                    mainBooleanQuery.AddChild(textBooleanQueryAnd, CutWith.AND);
                }


                filteredQuery.Query = mainBooleanQuery;
                filteredQuery.Filter = CreateFilterForSearchQueryString();


                filteredQuery.PageSize = m_oEpgSearchObj.m_nPageSize;
                filteredQuery.PageIndex = m_oEpgSearchObj.m_nPageIndex;


                if (!string.IsNullOrEmpty(m_oEpgSearchObj.m_sOrderBy))
                {
                    filteredQuery.ESSort.Add(new ESOrderObj()
                    {
                        m_eOrderDir = OrderDir.ASC,
                        m_sOrderValue = m_oEpgSearchObj.m_sOrderBy
                    });
                }

                res.Add(filteredQuery.ToString());
            }
            else
            {
                if (m_oEpgSearchObj.m_bIsCurrent)
                {
                    /*
                     * 1. IsCurrent means we received a request of type EpgRequest.
                     * 2. The flag current program in this request is turned on.
                     * 3. In this case we create 2 ES requests per epg channel id.
                     * 4. First request asks ES to bring epg programme ids which satisfy: 
                     *    a. DateTime.UtcNow > programme.start_date
                     *    b. PageSize = m_nPrevTop+1 (Current programme plus offset provided in the request)
                     *    c. Order by start_date desc (in ES language ofcourse :) )
                     * 5. Second request asks ES to bring epg programme ids which satisfy:
                     *    a. DateTime.UtcNow < programme.start_date
                     *    b. PageSize = m_nNextTop
                     *    c. Order by start_date asc
                     * 
                     */
                    string startDate = DateTime.UtcNow.ToString(Utils.ES_DATE_FORMAT);
                    for (int i = 0; i < m_oEpgSearchObj.m_oEpgChannelIDs.Count; i++)
                    {
                        FilteredQuery prevProgrammes = CreateFilteredQueryForCurrentRequest(true, i, startDate);
                        FilteredQuery nextProgrammes = CreateFilteredQueryForCurrentRequest(false, i, startDate);
                        res.Add(prevProgrammes.ToString());
                        res.Add(nextProgrammes.ToString());

                    } // for
                }
                else
                {
                    /*
                     * 1. Catalog received EpgRequest with flag ByDate.
                     * 2. For each channel id we create a request to fetch all programmes which satisfy:
                     *    a. Programmes are within the given dates. (See sections 3 and 4)
                     *    b. PageSize = given pageSize, pageIndex = given pageIndex
                     *    c. Order by start date
                     * 3. Which programmes are in the given range? It is easier to understand which programmes are OUTSIDE the given range.
                     *    So, which programmes are OUTSIDE the given range? All the programmes that satisfy the following conditions:
                     *    a. programme.endDate < request.startDate AND
                     *    b. programme.startDate > request.endDate
                     * 4. Applying De-Morgan Laws on section (3) gives us the initial answer:
                     *    a. programme.endDate >= request.startDate OR
                     *    b. programme.startDate <= request.endDate
                     * 5. The final answer consists of the following:
                     *    a. programme.startDate >= request.startDate AND
                     *    b. programme.endDate <= request.endDate AND
                     *    c. The boolean expression in section (4)
                     * 6. In Mathematical language we search for the following:
                     *    (request.endDate >= programme.endDate >= request.startDate) || (request.startDate <= programme.endDate <= request.endDate)
                     */

                    FilteredQuery fq = new FilteredQuery();

                    fq.Query = new ESMatchAllQuery();
                    fq.PageIndex = m_oEpgSearchObj.m_nPageIndex;
                    fq.PageSize = m_oEpgSearchObj.m_nPageSize;
                    fq.ESSort.Add(new ESOrderObj() { m_eOrderDir = OrderDir.ASC, m_sOrderValue = "start_date" });

                    QueryFilter filter = new QueryFilter();
                    BaseFilterCompositeType filterComposite = new FilterCompositeType(CutWith.AND);

                    BaseFilterCompositeType datesContraints = new FilterCompositeType(CutWith.OR);

                    // Section 4 boolean expression described above
                    ESRange startDateRange = new ESRange(false) { Key = "start_date" };
                    startDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.LTE, m_oEpgSearchObj.m_dEndDate.ToString(Utils.ES_DATE_FORMAT)));
                    startDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.GTE, m_oEpgSearchObj.m_dStartDate.ToString(Utils.ES_DATE_FORMAT)));
                    ESRange endDateRange = new ESRange(false) { Key = "end_date" };
                    endDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.GTE, m_oEpgSearchObj.m_dStartDate.ToString(Utils.ES_DATE_FORMAT)));
                    endDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.LTE, m_oEpgSearchObj.m_dEndDate.ToString(Utils.ES_DATE_FORMAT)));

                    if (m_oEpgSearchObj.m_bSearchEndDate)
                    {
                        ESRange searchEndDateRange = new ESRange(false) { Key = "search_end_date" };
                        searchEndDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.GT, m_oEpgSearchObj.m_dSearchEndDate.ToString(Utils.ES_DATE_FORMAT)));
                        filterComposite.AddChild(searchEndDateRange);
                    }

                    ESTerm isActiveTerm = new ESTerm(true) { Key = "is_active", Value = "1" };

                    datesContraints.AddChild(startDateRange);
                    datesContraints.AddChild(endDateRange);

                    
                    filterComposite.AddChild(isActiveTerm);
                    filterComposite.AddChild(datesContraints);
                    for (int i = 0; i < m_oEpgSearchObj.m_oEpgChannelIDs.Count; i++)
                    {
                        filter.FilterSettings = new EpgChannelsFilterCompositeType(filterComposite, new List<long>(1) { m_oEpgSearchObj.m_oEpgChannelIDs[i] });
                        fq.Filter = filter;
                        res.Add(fq.ToString());
                    }
                }
            }

            return res;

        }

        private FilteredQuery CreateFilteredQueryForCurrentRequest(bool isPrev, int index, string startDate)
        {
            FilteredQuery res = new FilteredQuery();
            
            res.Query = new ESMatchAllQuery();

            QueryFilter filter = new QueryFilter();
            BaseFilterCompositeType filterComposite = new FilterCompositeType(CutWith.AND);

            ESRange startDateRange = new ESRange(false) { Key = "start_date" };
            ESTerm isActiveTerm = new ESTerm(true) { Key = "is_active", Value = "1" };
            
            res.PageIndex = 0;

            if (isPrev)
            {
                res.ESSort.Add(new ESOrderObj() { m_eOrderDir = OrderDir.DESC,  m_sOrderValue = "start_date" });
                startDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.LTE, startDate));
                res.PageSize = m_oEpgSearchObj.m_nPrevTop + 1;
            }
            else
            {
                res.ESSort.Add(new ESOrderObj() { m_eOrderDir = OrderDir.ASC, m_sOrderValue = "start_date" });
                startDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.GT, startDate));
                res.PageSize = m_oEpgSearchObj.m_nNextTop;
            }

            filterComposite.AddChild(startDateRange);
            filterComposite.AddChild(isActiveTerm);
            
            filter.FilterSettings = new EpgChannelsFilterCompositeType(filterComposite, new List<long>(1) { m_oEpgSearchObj.m_oEpgChannelIDs[index] });
            res.Filter = filter;

            return res;
        }

        protected virtual QueryFilter CreateFilterForSearchQueryString()
        {
            QueryFilter filter = new QueryFilter();
            BaseFilterCompositeType filterComposite = new FilterCompositeType(CutWith.AND);

            string sStartDate = this.m_oEpgSearchObj.m_dStartDate.ToString(Utils.ES_DATE_FORMAT);
            string sStartMin = this.m_oEpgSearchObj.m_dStartDate.AddDays(-1).ToString(Utils.ES_DATE_FORMAT);
            string sStartMax = this.m_oEpgSearchObj.m_dEndDate.AddDays(1).AddSeconds(-1).ToString(Utils.ES_DATE_FORMAT);

            ESRange minStartDateRange = new ESRange(false) { Key = "start_date" };
            minStartDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.GTE, sStartMin));
            minStartDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.LTE, sStartMax));

            ESRange maxStartDateRange = new ESRange(false) { Key = "end_date" };
            maxStartDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.GTE, sStartDate));

            ESTerm isActiveTerm = new ESTerm(true) { Key = "is_active", Value = "1" };


            filterComposite.AddChild(minStartDateRange);
            filterComposite.AddChild(maxStartDateRange);
            filterComposite.AddChild(isActiveTerm);

            FillFilterSettings(ref filter, filterComposite);

            return filter;

        }

        protected void FillFilterSettings(ref QueryFilter filter, BaseFilterCompositeType filterSettings)
        {
            if (IsFilterByEpgChannelIDs())
            {
                filter.FilterSettings = new EpgChannelsFilterCompositeType(filterSettings, m_oEpgSearchObj.m_oEpgChannelIDs);
            }
            else
            {
                filter.FilterSettings = filterSettings;
            }
        }

        protected bool IsFilterByEpgChannelIDs()
        {
            return m_oEpgSearchObj != null && m_oEpgSearchObj.m_oEpgChannelIDs != null && m_oEpgSearchObj.m_oEpgChannelIDs.Count > 0;
        }

        public virtual string BuildEpgAutoCompleteQuery()
        {
            string sResult = string.Empty;

            if (m_oEpgSearchObj == null)
                return sResult;

            FilteredQuery filteredQuery = new FilteredQuery();
            MultiMatchQuery phrasePrefix = new MultiMatchQuery();

            if (m_oEpgSearchObj.m_lSearch.Count > 0)
            {
                #region build prefix query
                foreach (EpgSearchValue kvp in m_oEpgSearchObj.m_lSearch)
                {
                    phrasePrefix.Fields.Add(kvp.m_sKey.ToLower());
                }

                phrasePrefix.Query = m_oEpgSearchObj.m_lSearch[0].m_sValue.ToLower(); // search value is identical in all search fields

                filteredQuery.Query = phrasePrefix;
                #endregion


            }

            #region build filter - is_active, start/end date
            QueryFilter filter = new QueryFilter();
            BaseFilterCompositeType filterComposite = new FilterCompositeType(CutWith.AND);

            string sStartDate = this.m_oEpgSearchObj.m_dStartDate.ToString(Utils.ES_DATE_FORMAT);
            string sStartMin = this.m_oEpgSearchObj.m_dStartDate.AddDays(-1).ToString(Utils.ES_DATE_FORMAT);
            string sStartMax = this.m_oEpgSearchObj.m_dEndDate.AddDays(1).AddSeconds(-1).ToString(Utils.ES_DATE_FORMAT);

            ESRange minStartDateRange = new ESRange(false) { Key = "start_date" };
            minStartDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.GTE, sStartMin));
            minStartDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.LTE, sStartMax));

            ESRange maxStartDateRange = new ESRange(false) { Key = "end_date" };
            maxStartDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.GTE, sStartDate));

            ESTerm isActiveTerm = new ESTerm(true) { Key = "is_active", Value = "1" };


            filterComposite.AddChild(minStartDateRange);
            filterComposite.AddChild(maxStartDateRange);
            filterComposite.AddChild(isActiveTerm);
            FillFilterSettings(ref filter, filterComposite);


            filteredQuery.Filter = filter;
            #endregion

            filteredQuery.PageSize = m_oEpgSearchObj.m_nPageSize;
            filteredQuery.PageIndex = m_oEpgSearchObj.m_nPageIndex;

            sResult = filteredQuery.ToString();
            return sResult;
        }

        /*Build query by channelId and spesipic dates*/
        public static string BuildDeleteQuery(int channelID, List<DateTime> lDates)
        {
            string sQuery = string.Empty;

            ESTerm epgChannelTerm = new ESTerm(true) { Key = "epg_channel_id", Value = channelID.ToString() };

            BoolQuery oBoolQuery = new BoolQuery();


            BoolQuery oBoolQueryDates = new BoolQuery();
            foreach (DateTime date in lDates)
            {
                string sMaxtDate = date.AddDays(1).AddMilliseconds(-1).ToString("yyyyMMddHHmmss");

                ESRange startDateRange = new ESRange(false);

                startDateRange.Key = "start_date";
                string sMin = date.ToString("yyyyMMddHHmmss");
                startDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.GTE, sMin));
                startDateRange.Value.Add(new KeyValuePair<eRangeComp, string>(eRangeComp.LTE, sMaxtDate));

                oBoolQueryDates.AddChild(startDateRange, ApiObjects.SearchObjects.CutWith.OR);
            }

            oBoolQuery.AddChild(epgChannelTerm, ApiObjects.SearchObjects.CutWith.AND); // channel must be equel to channelID
            oBoolQuery.AddChild(oBoolQueryDates, ApiObjects.SearchObjects.CutWith.AND);// and start date must be in lDates list (with or between dates)

            sQuery = oBoolQuery.ToString();


            return sQuery;

        }
    }
}