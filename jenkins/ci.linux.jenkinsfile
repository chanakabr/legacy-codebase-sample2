library identifier: 'ott-lib-jenkins@fixOTTBackend', retriever: modernSCM([$class: 'GitSCMSource', credentialsId: 'github-ott-ci-cd', remote: 'https://github.com/kaltura/ott-lib-jenkins'])
pipeline {
    agent {
        label 'Linux'
    }
    options {
        buildDiscarder(logRotator(numToKeepStr:'50'))
        skipDefaultCheckout true
        disableConcurrentBuilds()
        quietPeriod(50)
    }
    environment{
        AWS_REGION="us-west-2"
        ECR_URL ='870777418594.dkr.ecr.us-west-2.amazonaws.com'
        component = "${env.JOB_NAME}"
        ECR_REPOSITORY="${ECR_URL}/${REPOSITORY_NAME}"
        STAGE = "build"
        PIPECLI = cd.get_pipecli()
    }
    // parameters {
    //     booleanParam(name: 'TRIGGER_RC', defaultValue: true, description: 'Should trigger Release Candidate?')
    // }
    stages {
        stage('Checkout'){
            steps{
                git(url: 'https://github.com/kaltura/ott-backend.git', branch: "${BRANCH_NAME}", credentialsId: "github-ott-ci-cd")
                script {
                    committerEmail = sh ( script: 'git --no-pager show -s --format=\'%ae\'', returnStdout: true ).trim() 
                    currentBuild.displayName = "#${BUILD_NUMBER}: ${BRANCH_NAME} - ${committerEmail}" }
            }
        }
        stage('Test')
        {
            steps
            {
                ansiColor('xterm') {
                    runTests()
                }
            }
            post
            {
                failure
                {
                    script
                    {
                        error "Tests have been failing so the build has been terminated. Please fix the tests."
                    }
                }
                unstable
                {
                    script
                    {
                        error "Tests have been failing so the build has been terminated. Please fix the tests."
                    }
                }
            }
        }
        stage ('ECR Login') {
            steps{
                sh(label: "ECR Login", script: "login=\$(aws ecr get-login --no-include-email --region ${AWS_REGION}) && \${login}")
            }
        }
        stage('Build Docker Images'){
            steps{                
                buildDockerAndPushToEcr("phoenix","Phoenix.Dockerfile")
                buildDockerAndPushToEcr("tvpapi","Tvpapi.Dockerfile")
                buildDockerAndPushToEcr("wsingest","WSIngest.Dockerfile")
                buildDockerAndPushToEcr("ingesthandlers","IngestHandlers.Dockerfile")
		        buildDockerAndPushToEcr("opc-migration","OPC_Migration.Dockerfile")
            }
        }
        stage("Trigger Release Candidate"){
            steps{
                script {
                    SHORT_JOB_NAME = sh (script: "echo ${JOB_NAME} | cut -f1 -d'/'", returnStdout: true).trim()  
                }
                build (
                    job: "OTT-BE-Create-Release-Candidate", 
                    wait: false,
                    parameters: [
                        [$class: 'StringParameterValue', name: 'BRANCH_NAME', value: "${BRANCH_NAME}"],
                        [$class: 'StringParameterValue', name: 'callingjob', value: "${SHORT_JOB_NAME}"],
                    ]
                )
                script {
                    component = "${env.JOB_NAME}"
                }

            }
        }
        stage("Trigger Sonar Scan"){
            when {
                expression {
                    BRANCH_NAME == "master"
                }
            }
            steps{
                build (
                    job: "OTT-BE-Sonar-Scan", 
                    wait: false,
                    parameters: [
                        [$class: 'StringParameterValue', name: 'BRANCH_NAME', value: "${BRANCH_NAME}"],
                        [$class: 'StringParameterValue', name: 'PROJECT', value: "ott-backend-netcore"],
                    ]
                )
            }
        }
    }
    post {
        always {
            report()
        }
    }
}

def runTests(){
    def testProjects = findDirectoriesWithTests()
    runTestInDocker(testProjects)
}

def findDirectoriesWithTests() {
    sh (script: "set +x;ls -d -- **/*.Tests", returnStdout: true).trim().split("\\r?\\n")
}

def runTestInDocker(testProjects){
    def GREEN="\u001B[32m"
    def RED="\u001B[31m"
    def ANSI_END="\u001B[0m"
    def BLUE="\u001B[34m"
    def CYAN="\u001B[36m"
    testProjects.any { project -> 
        if (currentBuild.result == 'FAILURE') {
            return true
        }
        echo "${GREEN}------------------------------------------- Starting Tests: ${project} -------------------------------------------${ANSI_END}"
        withTestbed(['DOTNET_CLI_HOME=/tmp/DOTNET_CLI_HOME'], "mcr.microsoft.com/dotnet/core/sdk:3.1-alpine", project) {
            def buildStatus = sh ( script: "dotnet build ${project}", returnStatus: true)
            if(buildStatus != 0) {
                echo "${RED}------------------------------------------- Building Test: ${project} FAILED!!! -------------------------------------------${ANSI_END}"
                currentBuild.result = 'FAILURE'
                error "1"
            }
            def testStatus = sh ( script: "dotnet test ${project} --no-build --logger \"junit;LogFilePath=./test-results.xml\"", returnStatus: true)
            if(testStatus != 0) {
                echo "${RED}------------------------------------------- Test: ${project} FAILED!!! -------------------------------------------${ANSI_END}"
                currentBuild.result = 'FAILURE'
                error "2"
            }
            junit "**/test-results.xml"
        }
    }
    if (currentBuild.result == 'SUCCESS') {
        echo "${GREEN}------------------------------------------- Finished All Tests!!! -------------------------------------------${ANSI_END}"
    }
}

def buildDockerAndPushToEcr(componentName, dockerfile){
    component = componentName
    def REPOSITORY_NAME="${BRANCH_NAME.toLowerCase()}/${componentName}"
    def ECR_REPOSITORY="${ECR_URL}/${REPOSITORY_NAME}"
    def GIT_COMMIT = sh(returnStdout: true, script: 'git rev-parse HEAD').trim() 
    def FULL_VERSION = sh(script: './Core/get-version-tag.sh', returnStdout: true).trim()
    sh(
        label: "Docker build ${REPOSITORY_NAME}", 
        script: "docker build "+
        "-f ${dockerfile} "+
        "-t ${ECR_REPOSITORY}:build  "+
        "-t ${ECR_REPOSITORY}:${GIT_COMMIT} "+
        "-t ${ECR_REPOSITORY}:${FULL_VERSION} "+
        "--build-arg BRANCH=${BRANCH_NAME} "+
        "--label 'version=${FULL_VERSION}' "+
        "--label 'commit=${GIT_COMMIT}' "+
        "--label 'build=${env.BUILD_NUMBER}' ."
    )

    sh(
        label: "Verify ECR Repository Exist", 
        script: "aws ecr describe-repositories --repository-names ${REPOSITORY_NAME} --region ${AWS_REGION} || "+
                "aws ecr create-repository --image-scanning-configuration scanOnPush=true --repository-name ${REPOSITORY_NAME} --region ${AWS_REGION}"
    )

    if (BRANCH_NAME =~ /\d+\d+\d+.*_/ || BRANCH_NAME =~ /\d+\d+\d+.*-/){
        sleep 5
        def is_exist = sh(script: "aws ecr get-lifecycle-policy --repository-name ${REPOSITORY_NAME} --region ${AWS_REGION}", returnStatus: true)
        if (is_exist != "0"){
            configFileProvider([configFile(fileId: '5ea8a9af-3adb-48ae-9929-3d93de8ff641', targetLocation: 'ECR-create-lifecycle.sh')]) {}
            sh( label: "Create ECR Repository Lifecycle Policy",
            script: "chmod +x ECR-create-lifecycle.sh && ./ECR-create-lifecycle.sh ${AWS_REGION} ${REPOSITORY_NAME}")
        }
    }
    
    sh(label: "Push Image", script: "docker push ${ECR_REPOSITORY}:build")
    sh(label: "Remove Image", script: "docker rmi -f ${ECR_REPOSITORY}:build")
    sh(label: "Push Image", script: "docker push ${ECR_REPOSITORY}:${GIT_COMMIT}")
    sh(label: "Remove Image", script: "docker rmi -f ${ECR_REPOSITORY}:${GIT_COMMIT}")
    sh(label: "Push Image", script: "docker push ${ECR_REPOSITORY}:${FULL_VERSION}")
    sh(label: "Remove Image", script: "docker rmi -f ${ECR_REPOSITORY}:${FULL_VERSION}")
    echo "Docker build image: ${ECR_REPOSITORY}:${FULL_VERSION}"
}

def report(){
    sh ("set +x;\$(aws ecr get-login --no-include-email --region ${AWS_REGION})")
    //configFileProvider([configFile(fileId: 'cec5686d-4d84-418a-bb15-33c85c236ba0', targetLocation: 'ReportJobStatus.sh')]) {}
    def committerEmail = sh ( script: 'set +x;git --no-pager show -s --format=\'%ae\'', returnStdout: true ).trim()
    def GIT_COMMIT = sh(label:"Obtain GIT Commit", script: "set +x;git rev-parse HEAD", returnStdout: true).trim();
    //def reportout = sh (script: "chmod +x ReportJobStatus.sh && ./ReportJobStatus.sh ${BRANCH_NAME} build ${env.BUILD_NUMBER} ${env.JOB_NAME} build ${currentBuild.currentResult} ${GIT_COMMIT} NA ${committerEmail}", returnStdout: true)
    //echo "${reportout}"
    def report = sh (script: "set +x;${PIPECLI} report job -b ${BRANCH_NAME} -s ${STAGE} --buildnum ${env.BUILD_NUMBER} --job ${env.JOB_NAME} --type build --buildstatus ${currentBuild.currentResult} --gitcommit ${GIT_COMMIT} --ecr NA --commiter ${committerEmail}", returnStdout: true)
}
